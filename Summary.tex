%Pakete;
%A4, Report, 12pt
\documentclass[ngerman,a4paper,12pt]{scrreprt}
\usepackage[a4paper, right=20mm, left=20mm,top=30mm, bottom=30mm, marginparsep=5mm, marginparwidth=5mm, headheight=7mm, headsep=15mm,footskip=15mm]{geometry}

%Papierausrichtungen
\usepackage{pdflscape}
\usepackage{lscape}

%Deutsche Umlaute, Schriftart, Deutsche Bezeichnungen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

%quellcode
\usepackage{listings}
\lstset{
  language=C,              % choose the language of the code
  numbers=left,                   % where to put the line-numbers
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{lightgray},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
}
\lstdefinestyle{sharpc}{language=[Sharp]C, frame=lrtb, rulecolor=\color{gray!80!gray}}

%tabellen
\usepackage{tabularx}

%listen und aufzählungen
\usepackage{paralist}

%farben
\usepackage[svgnames,table,hyperref]{xcolor}

%symbole
\usepackage{latexsym,textcomp}
\usepackage{amssymb}

%font
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

%durch- und unterstreichen
\usepackage{ulem}

%Abkürzungsverzeichnisse
\usepackage[printonlyused]{acronym}

%Bilder
\usepackage{graphicx} %Bilder
\usepackage{float}	  %"Floating" Objects, Bilder, Tabellen...
\usepackage[space]{grffile} %Leerzechen Problem bei includegraphics
\usepackage{wallpaper} %Seitenhintergrund setzen
\usepackage{transparent} %Transparenz

%Tikz, Mindmaps, Trees
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

%for
\usepackage{forloop}
\usepackage{ifthen}

%Dokumenteigenschaften
\title{Summary}
\author{Tobias Blaser}
\date{\today{}, Uster}


%Kopf- /Fusszeile
\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie

%Kopf-/ Fusszeile auf chapter page
\fancypagestyle{plain} {
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
}

\usepackage{changepage}

% Abkürzungen für Kapitel, Titel und Listen
\input{toolsAndCommands/shortcutsListAndChapter}
\input{toolsAndCommands/TextStructuringBoxes}

%links, verlinktes Inhaltsverzeichnis, PDF Inhaltsverzeichnis
\usepackage[bookmarks=true,
bookmarksopen=true,
bookmarksnumbered=true,
breaklinks=true,
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
menucolor=black,
pagecolor=black,
urlcolor=black
]{hyperref} % Paket muss unbedingt als letzes eingebunden werden!

\usepackage{graphicx}
\begin{document}
\lstset{style=sharpc}

% Inhaltsverzeichnis
\tableofcontents
\clearpage


\ch{.Net}
	\se{CLR}
		\stdImg{v1.1}{Common Language Runtime}
		\expl{Managed Code}{Managed Code wird unter Aufsiicht des CRL ausgeführt (Security Manager, GC, ...)}
	
	\se{Common Type System CTS}
		\stdImg{v1.2}{CTS}
		\expl{Struct}{Wertobjekt, kein Ref. Type, unterschiedlich zu C!}
		
		\sse{Ref Types}
			\stdImg{v1.3}{Ref Type}
			XY.PointR entält Reflection Info.
			
		\sse{Value Types}
			\stdImg{v1.4}{Value Type (nur auf dem Stack}
			Konstruktor ist kein Konstruktor sondern nur ein Initialisierer der Werte auf dem Stack!
			
		\sse{Unterschiede}
			Aufpassen. Syntax genau gleich!
			\stdImg{v1.5}{Syntax / Hardware}
			\stdImg{v1.7}{Unterschiede Struct und Member}
			
		\sse{Boxing}
			\stdImg{v1.6}{}
			Boxing ist eine teuere Operation und erzeugt eine menge Garbage!
			
		\sse{MS Intermediate Language}
			\stdImg{v1.8}{IL}
			\stdImg{v1.9}{}
			\uli{
				\li Fehlt während der Laufzeit eine Klassenmethode als Native Code, wird der JIT Compiler aufgerufen und der IL Code mit dem Native Code ersetzt.	
				\li Typesafty kann zur Laufzeit überprüft werden in der IL
				\li IL wird nicht ausgeführt sondern zur Laufzeit compiliert!
			}
			
	\se{Assemblies}
		\expl{Assembly}{Deployment Einheit (exe, dll) im Portable Executable Format}
		\stdImg{v1.11}{}
		\expl{Module .Net}{IL Code+Metadata, Tools (z.B. ILDASM)
			\uli{
				\li C++: dll+Headerfile
				\li Java: Jar (Enthält Headerfileinfo werden über Reflection aus dem Jar extrahiert)
				\li .Net: dll/exe (wie Java)	
			}
		}
		\expl{Unterschied Komponente / Klasse in UML}{Komponente: Blackbox mit Interfaces}
		\stdImg{v1.10}{.Net dll}
		
		\sse{Type Resolution}
			Nicht über Filepath wie in Java sondern in den Metadata festgeschrieben.
			\stdImg{v1.12}{Assemblies Abhängigkeiten}
			
\ch{C\#}
	\se{Garbage Collection}
		\uli{
			\li Heap Algorithmus, läuft über erreichbarkeit, arbeitet mit Generationen.
			\li Aufräumen ist langsam, allozieren schnell.
		}
		
	\se{Namespaces}
		\stdImg{v1.13}{.Net Namespaces}
		\stdImg{v1.14}{Namespace und asso. DLL}
		
	\se{Classes}
		\stdImg{v1.15}{Alles wird UpperCamelcase benannt, nur Felder sind lowerCamelCase}
		
	\se{Einfache Typen}
		\stdImg{v1.16}{einfache Typen}
		
	\se{Referenztypen}
		\sse{Arrays}
			\stdImg{v1.17}{Unterschied jagged und block Array}
			
		\sse{Enum}
			\stdImg{v1.18}{}
			\stdImg{v1.19}{}
			
		\sse{String}
			\uli{
				\li Referenztyp
				\li Nicht modifizierbar (StringBuilder bentzen)
				\li Operatoren: +, [], Length
				\li Wertvergleich mit == und !=
			}
			
		\sse{Klassen}
			\stdImg{v1.20}{}
			\uli{
				\li Virtual kennzeichnet Methoden mit dnamic binding
				\li overwrite kennzeichnet Methodenüberschreibungen
				\li base. ruft Basiskonstruktor auf
			}
			\examp{Referenziertes Objekt wird = null zugewiesen}{Das Objekt wird vom GC abgeräumt, auch wenn noch referenzen darauf zeigen.}
			\stdImg{v1.21}{Unterschied Klasse und Structs}
			
		\sse{Boxing}
			Aufpassen mit Boxing! Auto-Boxing nur für lesende Zugriffe verwenden, nie für Zuweisungen.
		\sse{Punkt Operator}
			Punkt Operator wird sowohl für Dereferenzierung wir für Feldzugriff verwendet. (In C++ wird der Pfeil als Dereferenzierungsoperator verwendet und der Punkt nur für Felderzugriff (Klasse, Struct).
			
	\se{Klassen}
		\sse{Methoden}
			\uli{
				\li Mit ref deklarierte Variable muss auch wieder mit ref angesprochen werden.
			}
			\stdImg{v1.22}{Arten von Parametern}
		
		
		\sse{Konstruktoren}
			\stdImg{v1.23}{}
		
			\sse{Statische Konstruktoren}
				\stdImg{v1.24}{Statische Konstruktoren}
			
		\sse{Destruktor}
			Ist genau genommen ein finalizer und kein Destruktor. Macht den GC langsam.
		
		\sse{Properties}
			\definition{Properties}{Berechnete Felder}
			\stdImg{v1.25}{Properties}
		
			\sse{Automatische Konstruktoren}
				\begin{verbatim}
					public string Name { get; set; }
				\end{verbatim}
			
		\sse{Indexer}
			\definition{Indexer}{Index Operator}
			\stdImg{v1.26}{}
		
		\sse{Vererbung}
			Syntax wie bei C++:
			\begin{verbatim}
				class B:A {
					...
				}
			\end{verbatim}

			\expl{Statische und dynamische Typen}{
				\\
					A a = new A(); // statischer Typ von a ist immer A, dynamischer Typ ist hier auch A\\
					a = new B(); // statischer Typ unverändert, dynamischer Typ ist B
				\\
			}
		
			\stdImg{v1.27}{Geprüfte Typenumwandlungen}
		
			\sss{Dynamic Binding}
				\expl{Statische und dynamische Methodenaufrufe}{Beim Virtual Binding geht die Methodenauflösung über das Objekt und über dessen Klasse, beim statischen Binding direkt über den Basistyp \ra\ ruft Methode des Basistyps auf.}
				\expl{virtual und dynamic binding}{Virtual braucht es nur dann, wenn ANSTELLE des Objektes A, ein Kindobjekt verwendet werden soll. Z.B. eine Schnittstelle, die A-Objekte oder A-Kinder erwartet. In der Realität ist der Fall sehr selten und darum bei C\# nicht standard.}
				\examp{Dynamic Binding}{User Interface mit Window Elementen wie Buttons, Scrollpane, ... die alle von ``Window'' abgeleitet sind. Der Window Manager besitzt eine Collection mit ``Window'' Elementen, durch die er iteriert und für jedes Objekt seine eigene paint methode ``public void paint()'' aufruft. Bei Static Binding würde die paint() Methode der Window Klasse aufgerufen und nicht diejenige des übergebenen Elementes.}
			
				\important{new virtual verdeckt weitere Overrides von Obgeleiteten Klassen. Der Compiler geht von oben nach unten in der Klassenhirarchie. new virtual unterbricht diese Hirarchie.}
				\stdImg{v1.29}{DB mit Verdecken}
			
			\sss{Ober- und Unterklassen Konstruktoren}
				Statische Elemente vor Dynamischen! Statische Felder vor Instanzfelder!
				\stdImg{v1.30}{}
				\stdImg{v1.31}{}
			
	\se{Interfaces}
		Methoden sind per default public, dürfen also nicht public definiert werden \ra\ Kompiler motzt sonst.
	
		\begin{verbatim}
			class MyClass : MyInterface {
		
			}
		\end{verbatim}
			
		\sse{Named Clashes}
			Mehrere Interfaces mit gleicher Methode \ra\ angeben welche man implemtentiert (optional).
			\stdImg{v1.32}{Named Clashes}
			
	\se{Optionale Parameter}
		\stdImg{v1.33}{Optionale Parameter}
		Ist der optionale Parameter nicht der hinterste, kann man durch naming diesen angeben:
		\begin{verbatim}
			function(int a, int b, aut = 5, int from, int aso, int to = 100) {
				...s
			}
		
			function(a, b, from: 100, to: 200);
		\end{verbatim}

	\se{Partial Methods}
		Hooks
		\stdImg{v1.34}{}
		Nur verwenden für Code Generatoren!

	\se{Delegates}
		\definition{Delegate}{Methodentyp. Methode als Variable übergeben wie im JS. Methode wird anschliessend aufgerufen.}
		\stdImg{v1.35}{Delegate}
		
		\expl{Anonyme Interfaces}{.Net kennt keine Anonymen Interfaces wie Java.}
		
		\begin{lstlisting}
			delegate bool check(Payment p);			
			public function ammount(int ammount, check) {
				...
			}
			
			ammount(1500, function(Payment p) { 
				return p.Ammount > 0; 
			}
		\end{lstlisting}
		
		\stdImg{v1.48}{In C\# gibt es nur Multicast Delegates!}
		
		\important{Delegates sind wie Strings unveränderbar! + und - Operationen auf Delegates adden und entfernen nicht wie erwartet sondern rufen combine auf. Combine fügt der Bestehenden Kette ein neues Element hinzu indem damit ein neues Delegate erstellt wird, das dem alten zugewiesen wird.}
		\stdImg{v1.49}{}
		
	\se{Events}
		Delegates als Observer. Umsetzung von Callbacks.
		
		\stdImg{v1.36}{Events}
		\exam{Event kommt eine Aufgabe an Prüfung}
		\stdImg{v1.37}{Examp: Client}
		\stdImg{v1.38}{Examp 2}
		\stdImg{v1.39}{.Net Event Handlers}	
		
		\lstinputlisting{code/Counter.cs}
		\lstinputlisting{code/CounterClient.cs}
		
		\sse{Erweiterungen}
			\stdImg{v1.40}{Automatische ergänzung von new Class {} durch den Compiler (rot)}
			\stdImg{v1.41}{Anonyme Methoden}
			\stdImg{v1.42}{Nicht benutzte Parameter des Delegate können weggelassen werden.}
	
	\se{Closures}
		Benutzte lokale Variablen werden in ein Objekt gepackt, damit sie für den Delegate noch verfügbar sind. (Call by Reference)
		\stdImg{v1.43}{Closures}

	\se{Generics}
		\sse{Delegate Generics}
			\stdImg{v1.44}{Delegate Generic}
			
	\se{Exceptions}
		Fast Identisch wie in Java
		\stdImg{v1.45}{Try - Catch}
		Finally wird immer durchlaufen.
		\stdImg{v1.46}{System.Exception}
		\stdImg{v1.47}{Exception Hirarchie}
		
	
\ch{Generics}
	\se{Generische Typen}
		\sse{Platzhalter}
			Spezifische Typen werden zur Laufzeit zu spezifischen Klassen kompiliert. Für Referenztypen wird immer eine konkrete Klasse vom Typ Object verwendet, bei basistypen für jeden Type eine einzelne, die bei der ersten Verwendung kompiliert wird.
			\stdImg{v2.1}{Platzhalter}
			Auch Basistypen können für Generics verwendet werden.
			\stdImg{v2.2}{Mehrere Platzhalter}
	
		\sse{Constraints}
			\stdImg{v2.6}{Constraints}
			\stdImg{v2.3}{Einschränken des Platzhaltertypen}
			\stdImg{v2.4}{Multiple Constraints}
			\stdImg{v2.5}{Parent und Konstruktor Constraints}
			Platzhalter können auch für Constraints verwendet werden.
			\stdImg{v2.7}{Platzhalter Constraints}
			\stdImg{v2.14}{Methoden Constraints}
			
		\sse{Inheritance}
			\stdImg{v2.8}{}
			\stdImg{v2.9}{Kompatibilität von Zuweisungen}
			\stdImg{v2.10}{Überschreiben von Generic Methoden}

		\sse{Null-Initialisierung}
			\stdImg{v2.11}{Nullwerte}
			\stdImg{v2.12}{Nullable (Null für Werttypen)}
			\stdImg{v2.13}{Nullable Kurzform}

	\se{Delegates und Lambda}
		\stdImg{v2.16}{}
		\stdImg{v2.15}{Lambda Expression}
		\stdImg{v2.17}{}
		
		\sse{Func}
		\stdImg{v2.18}{Vordefinierte generische Delegates zur Verwendung}

	\se{Collections}
		\stdImg{v2.19}{System.Collections.Generic}
		\stdImg{v2.20}{Nicht generic Pendants}
		
	\se{Iteratoren}
		\stdImg{v2.26}{Iteratoren von Hand}
		\stdImg{v2.21}{generische Iteratoren}
		\stdImg{v2.22}{Vereinfachte Implementation mit yield}
		\uli{
			\li Yield springt jeweils wieder aus der Funktion raus und fügt den Code in die aufrufende foreach Funktion ein.
			\li Yield gibt einen IEnummerator.Current zurück und fährt weiter, sobald MoveNext aufgerufen wird.
			\li Könnte auch simuliert werden mit einem übergebenen Delegate, das anstelle dem ``yield return'' aufgerufen wird.
		}
		\exam{Zur Vorbereitung: mit dem Debugger durch ein Foreach/Yield Konstrukt durchsteppen}
		\stdImg{v2.23}{Was passiert hinter den Kulissen?}
		\stdImg{v2.24}{Yield}
		\stdImg{v2.25}{Example}

\ch{Linq}
	\uli{
		\li Linq kann alles abfragen, was IEnummerable<T> implementiert.
		\li Linq ist eine reine Compilertechnologie
	}
	\stdImg{v3.4}{}
	Typensichere Abfragesprache für Objekte, Listen, ...
	\stdImg{v3.1}{Linq to Object}
	\stdImg{v3.2}{Linq to SQL}
	\stdImg{v3.3}{Linq to XML}
	
	\se{Erweiterungsmethoden}
		\uli{
			\li Bestehende Klassen um Methoden erweitern mit einer Statischen Klasse mit statischen Methoden durch die Angabe von ``this OriginalClass''.
			\li Reine Compilerfunktion. Der Compiler löst die Methode auf und schreibt ``ExtendOriginalClass.function()''
		}
		\stdImg{v3.5}{}
		\stdImg{v3.6}{Example}
		
		\sse{Predeclared Extension Methods}
			\stdImg{v3.7}{}
			\stdImg{v3.8}{Overrite Linq Extension Method}
			
		\sse{Object Initializers}
			\stdImg{v3.9}{}
			
		\sse{Anonyme Typen}
			Typensichere anonyme Typen, die zur Laufzeit generiert werden.
			\stdImg{v3.10}{}
			\stdImg{v3.10}{Anonyme Typen aus Eigenschaften von Anonymen Typen bauen}
			\stdImg{v3.11}{Anonyme Typen aus Anonymen Typen bauen}
			\stdImg{v3.12}{Anonymous Type Details}
			\stdImg{v3.13}{Type Inference}
			
		\sse{Query Expression}
			\stdImg{v3.22}{}
			\stdImg{v3.14}{Umwandlung in Erweiterungssyntax}
			\uli{
				\li Compiler wandelt Query Expression um in Erweiterungssyntax
				\li 
			}
			\stdImg{v3.15}{Query Syntax}
			
			\sss{Grouping}
				\stdImg{v3.16}{Group into}

			\sss{Joining Lists}
				\stdImg{v3.17}{Join Lists}
				
			\sse{Select Many}
				Mehrstufingen Aufsplittprozess
				\stdImg{v3.18}{String split}
				
			\sss{Group Joins}
				Liste mit Sublisten ausgeben (Strukturierte Daten).
				\stdImg{v3.19}{Strukturierte Collection}
				\stdImg{v3.20}{Left Outer Join (wenn keine Daten zum Namen vorhanden wird null eingefügt)}
				
		\sse{System.Linq Extension Methods}
			\stdImg{v3.21}{}

		\sse{Partial Methods (Hooks)}
			Könnte auch mit Delegates und Interfaces umgesetzt werden. Vereinfacht nur die Schreibweise.
			\stdImg{v3.23}{}
			\stdImg{v3.24}{}
			\stdImg{v3.25}{Example}
			
			
\ch{Entity Framework}
	using (...) verwendet eine Resource die beim Beenden automatisch geschlosse wird.
	\stdImg{v4.1}{EF}
	\stdImg{v4.2}{EF Architektur}
	\stdImg{v4.3}{Providers}
	Entities sind Objekte mit einem Primärschlüssel weil sie einem Datensatz in der Datenbank entsprechen.
	\stdImg{v4.4}{OR Mapping}	
	\stdImg{v4.5}{}
	
	\se{Lazy Loading}
		\stdImg{v4.6}{}
		\stdImg{v4.7}{}
	
	\se{Eager Loading}
		\stdImg{v4.8}{}	
			
		
	\se{CUD Operationen}
		
			

\end{document}
