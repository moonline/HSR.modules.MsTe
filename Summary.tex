%Pakete;
%A4, Report, 12pt
\documentclass[ngerman,a4paper,12pt]{scrreprt}
\usepackage[a4paper, right=20mm, left=20mm,top=30mm, bottom=30mm, marginparsep=5mm, marginparwidth=5mm, headheight=7mm, headsep=15mm,footskip=15mm]{geometry}

%Papierausrichtungen
\usepackage{pdflscape}
\usepackage{lscape}

%Deutsche Umlaute, Schriftart, Deutsche Bezeichnungen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

%quellcode
\usepackage{listings}
\lstset{
  language=C,              % choose the language of the code
  numbers=left,                   % where to put the line-numbers
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{lightgray},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
}
\lstdefinestyle{sharpc}{language=[Sharp]C, frame=lrtb, rulecolor=\color{gray!80!gray}}

%tabellen
\usepackage{tabularx}

%listen und aufzählungen
\usepackage{paralist}

%farben
\usepackage[svgnames,table,hyperref]{xcolor}

%symbole
\usepackage{latexsym,textcomp}
\usepackage{amssymb}

%font
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

%durch- und unterstreichen
\usepackage{ulem}

%Abkürzungsverzeichnisse
\usepackage[printonlyused]{acronym}

%Bilder
\usepackage{graphicx} %Bilder
\usepackage{float}	  %"Floating" Objects, Bilder, Tabellen...
\usepackage[space]{grffile} %Leerzechen Problem bei includegraphics
\usepackage{wallpaper} %Seitenhintergrund setzen
\usepackage{transparent} %Transparenz

%Tikz, Mindmaps, Trees
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

%for
\usepackage{forloop}
\usepackage{ifthen}

%Dokumenteigenschaften
\title{Summary}
\author{Tobias Blaser}
\date{\today{}, Uster}


%Kopf- /Fusszeile
\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie

%Kopf-/ Fusszeile auf chapter page
\fancypagestyle{plain} {
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
}

\usepackage{changepage}

% Abkürzungen für Kapitel, Titel und Listen
\input{toolsAndCommands/shortcutsListAndChapter}
\input{toolsAndCommands/TextStructuringBoxes}

%links, verlinktes Inhaltsverzeichnis, PDF Inhaltsverzeichnis
\usepackage[bookmarks=true,
bookmarksopen=true,
bookmarksnumbered=true,
breaklinks=true,
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
menucolor=black,
pagecolor=black,
urlcolor=black
]{hyperref} % Paket muss unbedingt als letzes eingebunden werden!

\usepackage{graphicx}
\begin{document}
\lstset{style=sharpc}

% Inhaltsverzeichnis
\tableofcontents
\clearpage


\ch{.Net}
	\se{CLR}
		\stdImg{v1.1}{Common Language Runtime}
		\expl{Managed Code}{Managed Code wird unter Aufsiicht des CRL ausgeführt (Security Manager, GC, ...)}
	
	\se{Common Type System CTS}
		\stdImg{v1.2}{CTS}
		\expl{Struct}{Wertobjekt, kein Ref. Type, unterschiedlich zu C!}
		
		\sse{Ref Types}
			\stdImg{v1.3}{Ref Type}
			XY.PointR entält Reflection Info.
			
		\sse{Value Types}
			\stdImg{v1.4}{Value Type (nur auf dem Stack}
			Konstruktor ist kein Konstruktor sondern nur ein Initialisierer der Werte auf dem Stack!
			
		\sse{Unterschiede}
			Aufpassen. Syntax genau gleich!
			\stdImg{v1.5}{Syntax / Hardware}
			\stdImg{v1.7}{Unterschiede Struct und Member}
			
		\sse{Boxing}
			\stdImg{v1.6}{}
			Boxing ist eine teuere Operation und erzeugt eine menge Garbage!
			
		\sse{MS Intermediate Language}
			\stdImg{v1.8}{IL}
			\stdImg{v1.9}{}
			\uli{
				\li Fehlt während der Laufzeit eine Klassenmethode als Native Code, wird der JIT Compiler aufgerufen und der IL Code mit dem Native Code ersetzt.	
				\li Typesafty kann zur Laufzeit überprüft werden in der IL
				\li IL wird nicht ausgeführt sondern zur Laufzeit compiliert!
			}
			
	\se{Assemblies}
		\expl{Assembly}{Deployment Einheit (exe, dll) im Portable Executable Format}
		\stdImg{v1.11}{}
		\expl{Module .Net}{IL Code+Metadata, Tools (z.B. ILDASM)
			\uli{
				\li C++: dll+Headerfile
				\li Java: Jar (Enthält Headerfileinfo werden über Reflection aus dem Jar extrahiert)
				\li .Net: dll/exe (wie Java)	
			}
		}
		\expl{Unterschied Komponente / Klasse in UML}{Komponente: Blackbox mit Interfaces}
		\stdImg{v1.10}{.Net dll}
		
		\sse{Type Resolution}
			Nicht über Filepath wie in Java sondern in den Metadata festgeschrieben.
			\stdImg{v1.12}{Assemblies Abhängigkeiten}
			
\ch{C\#}
	\se{Garbage Collection}
		\uli{
			\li Heap Algorithmus, läuft über erreichbarkeit, arbeitet mit Generationen.
			\li Aufräumen ist langsam, allozieren schnell.
		}
		
	\se{Namespaces}
		\stdImg{v1.13}{.Net Namespaces}
		\stdImg{v1.14}{Namespace und asso. DLL}
		
	\se{Classes}
		\stdImg{v1.15}{Alles wird UpperCamelcase benannt, nur Felder sind lowerCamelCase}
		
	\se{Einfache Typen}
		\stdImg{v1.16}{einfache Typen}
		
	\se{Referenztypen}
		\sse{Arrays}
			\stdImg{v1.17}{Unterschied jagged und block Array}
			
		\sse{Enum}
			\stdImg{v1.18}{}
			\stdImg{v1.19}{}
			
		\sse{String}
			\uli{
				\li Referenztyp
				\li Nicht modifizierbar (StringBuilder bentzen)
				\li Operatoren: +, [], Length
				\li Wertvergleich mit == und !=
			}
			
		\sse{Klassen}
			\stdImg{v1.20}{}
			\uli{
				\li Virtual kennzeichnet Methoden mit dnamic binding
				\li overwrite kennzeichnet Methodenüberschreibungen
				\li base. ruft Basiskonstruktor auf
			}
			\examp{Referenziertes Objekt wird = null zugewiesen}{Das Objekt wird vom GC abgeräumt, auch wenn noch referenzen darauf zeigen.}
			\stdImg{v1.21}{Unterschied Klasse und Structs}
			
		\sse{Boxing}
			Aufpassen mit Boxing! Auto-Boxing nur für lesende Zugriffe verwenden, nie für Zuweisungen.
		\sse{Punkt Operator}
			Punkt Operator wird sowohl für Dereferenzierung wir für Feldzugriff verwendet. (In C++ wird der Pfeil als Dereferenzierungsoperator verwendet und der Punkt nur für Felderzugriff (Klasse, Struct).
			
	\se{Klassen}
		\sse{Methoden}
			\uli{
				\li Mit ref deklarierte Variable muss auch wieder mit ref angesprochen werden.
			}
			\stdImg{v1.22}{Arten von Parametern}
		
		
		\sse{Konstruktoren}
			\stdImg{v1.23}{}
		
			\sse{Statische Konstruktoren}
				\stdImg{v1.24}{Statische Konstruktoren}
			
		\sse{Destruktor}
			Ist genau genommen ein finalizer und kein Destruktor. Macht den GC langsam.
		
		\sse{Properties}
			\definition{Properties}{Berechnete Felder}
			\stdImg{v1.25}{Properties}
		
			\sse{Automatische Konstruktoren}
				\begin{verbatim}
					public string Name { get; set; }
				\end{verbatim}
			
		\sse{Indexer}
			\definition{Indexer}{Index Operator}
			\stdImg{v1.26}{}
		
		\sse{Vererbung}
			Syntax wie bei C++:
			\begin{verbatim}
				class B:A {
					...
				}
			\end{verbatim}

			\expl{Statische und dynamische Typen}{
				\\
					A a = new A(); // statischer Typ von a ist immer A, dynamischer Typ ist hier auch A\\
					a = new B(); // statischer Typ unverändert, dynamischer Typ ist B
				\\
			}
		
			\stdImg{v1.27}{Geprüfte Typenumwandlungen}
		
			\sss{Dynamic Binding}
				\expl{Statische und dynamische Methodenaufrufe}{Beim Virtual Binding geht die Methodenauflösung über das Objekt und über dessen Klasse, beim statischen Binding direkt über den Basistyp \ra\ ruft Methode des Basistyps auf.}
				\expl{virtual und dynamic binding}{Virtual braucht es nur dann, wenn ANSTELLE des Objektes A, ein Kindobjekt verwendet werden soll. Z.B. eine Schnittstelle, die A-Objekte oder A-Kinder erwartet. In der Realität ist der Fall sehr selten und darum bei C\# nicht standard.}
				\examp{Dynamic Binding}{User Interface mit Window Elementen wie Buttons, Scrollpane, ... die alle von ``Window'' abgeleitet sind. Der Window Manager besitzt eine Collection mit ``Window'' Elementen, durch die er iteriert und für jedes Objekt seine eigene paint methode ``public void paint()'' aufruft. Bei Static Binding würde die paint() Methode der Window Klasse aufgerufen und nicht diejenige des übergebenen Elementes.}
			
				\important{new virtual verdeckt weitere Overrides von Obgeleiteten Klassen. Der Compiler geht von oben nach unten in der Klassenhirarchie. new virtual unterbricht diese Hirarchie.}
				\stdImg{v1.29}{DB mit Verdecken}
			
			\sss{Ober- und Unterklassen Konstruktoren}
				Statische Elemente vor Dynamischen! Statische Felder vor Instanzfelder!
				\stdImg{v1.30}{}
				\stdImg{v1.31}{}
			
	\se{Interfaces}
		Methoden sind per default public, dürfen also nicht public definiert werden \ra\ Kompiler motzt sonst.
	
		\begin{verbatim}
			class MyClass : MyInterface {
		
			}
		\end{verbatim}
			
		\sse{Named Clashes}
			Mehrere Interfaces mit gleicher Methode \ra\ angeben welche man implemtentiert (optional).
			\stdImg{v1.32}{Named Clashes}
			
	\se{Optionale Parameter}
		\stdImg{v1.33}{Optionale Parameter}
		Ist der optionale Parameter nicht der hinterste, kann man durch naming diesen angeben:
		\begin{verbatim}
			function(int a, int b, aut = 5, int from, int aso, int to = 100) {
				...s
			}
		
			function(a, b, from: 100, to: 200);
		\end{verbatim}

	\se{Partial Methods}
		Hooks
		\stdImg{v1.34}{}
		Nur verwenden für Code Generatoren!

	\se{Delegates}
		\definition{Delegate}{Methodentyp. Methode als Variable übergeben wie im JS. Methode wird anschliessend aufgerufen.}
		\stdImg{v1.35}{Delegate}
		
		\expl{Anonyme Interfaces}{.Net kennt keine Anonymen Interfaces wie Java.}
		
		\begin{lstlisting}
			delegate bool check(Payment p);			
			public function ammount(int ammount, check) {
				...
			}
			
			ammount(1500, function(Payment p) { 
				return p.Ammount > 0; 
			}
		\end{lstlisting}
		
		\stdImg{v1.48}{In C\# gibt es nur Multicast Delegates!}
		
		\important{Delegates sind wie Strings unveränderbar! + und - Operationen auf Delegates adden und entfernen nicht wie erwartet sondern rufen combine auf. Combine fügt der Bestehenden Kette ein neues Element hinzu indem damit ein neues Delegate erstellt wird, das dem alten zugewiesen wird.}
		\stdImg{v1.49}{}
		
	\se{Events}
		Delegates als Observer. Umsetzung von Callbacks.
		
		\stdImg{v1.36}{Events}
		\exam{Event kommt eine Aufgabe an Prüfung}
		\stdImg{v1.37}{Examp: Client}
		\stdImg{v1.38}{Examp 2}
		\stdImg{v1.39}{.Net Event Handlers}	
		
		\lstinputlisting{code/Counter.cs}
		\lstinputlisting{code/CounterClient.cs}
		
		\sse{Erweiterungen}
			\stdImg{v1.40}{Automatische ergänzung von new Class {} durch den Compiler (rot)}
			\stdImg{v1.41}{Anonyme Methoden}
			\stdImg{v1.42}{Nicht benutzte Parameter des Delegate können weggelassen werden.}
	
	\se{Closures}
		Benutzte lokale Variablen werden in ein Objekt gepackt, damit sie für den Delegate noch verfügbar sind. (Call by Reference)
		\stdImg{v1.43}{Closures}

	\se{Generics}
		\sse{Delegate Generics}
			\stdImg{v1.44}{Delegate Generic}
			
	\se{Exceptions}
		Fast Identisch wie in Java
		\stdImg{v1.45}{Try - Catch}
		Finally wird immer durchlaufen.
		\stdImg{v1.46}{System.Exception}
		\stdImg{v1.47}{Exception Hirarchie}
		
	
\ch{Generics}
	\se{Generische Typen}
		\sse{Platzhalter}
			Spezifische Typen werden zur Laufzeit zu spezifischen Klassen kompiliert. Für Referenztypen wird immer eine konkrete Klasse vom Typ Object verwendet, bei basistypen für jeden Type eine einzelne, die bei der ersten Verwendung kompiliert wird.
			\stdImg{v2.1}{Platzhalter}
			Auch Basistypen können für Generics verwendet werden.
			\stdImg{v2.2}{Mehrere Platzhalter}
	
		\sse{Constraints}
			\stdImg{v2.6}{Constraints}
			\stdImg{v2.3}{Einschränken des Platzhaltertypen}
			\stdImg{v2.4}{Multiple Constraints}
			\stdImg{v2.5}{Parent und Konstruktor Constraints}
			Platzhalter können auch für Constraints verwendet werden.
			\stdImg{v2.7}{Platzhalter Constraints}
			\stdImg{v2.14}{Methoden Constraints}
			
		\sse{Inheritance}
			\stdImg{v2.8}{}
			\stdImg{v2.9}{Kompatibilität von Zuweisungen}
			\stdImg{v2.10}{Überschreiben von Generic Methoden}

		\sse{Null-Initialisierung}
			\stdImg{v2.11}{Nullwerte}
			\stdImg{v2.12}{Nullable (Null für Werttypen)}
			\stdImg{v2.13}{Nullable Kurzform}

	\se{Delegates und Lambda}
		\stdImg{v2.16}{}
		\stdImg{v2.15}{Lambda Expression}
		\stdImg{v2.17}{}
		
		\sse{Func}
		\stdImg{v2.18}{Vordefinierte generische Delegates zur Verwendung}

	\se{Collections}
		\stdImg{v2.19}{System.Collections.Generic}
		\stdImg{v2.20}{Nicht generic Pendants}
		
	\se{Iteratoren}
		\stdImg{v2.26}{Iteratoren von Hand}
		\stdImg{v2.21}{generische Iteratoren}
		\stdImg{v2.22}{Vereinfachte Implementation mit yield}
		\uli{
			\li Yield springt jeweils wieder aus der Funktion raus und fügt den Code in die aufrufende foreach Funktion ein.
			\li Yield gibt einen IEnummerator.Current zurück und fährt weiter, sobald MoveNext aufgerufen wird.
			\li Könnte auch simuliert werden mit einem übergebenen Delegate, das anstelle dem ``yield return'' aufgerufen wird.
		}
		\exam{Zur Vorbereitung: mit dem Debugger durch ein Foreach/Yield Konstrukt durchsteppen}
		\stdImg{v2.23}{Was passiert hinter den Kulissen?}
		\stdImg{v2.24}{Yield}
		\stdImg{v2.25}{Example}

\ch{Linq}
	\uli{
		\li Linq kann alles abfragen, was IEnummerable<T> implementiert.
		\li Linq ist eine reine Compilertechnologie
	}
	\stdImg{v3.4}{}
	Typensichere Abfragesprache für Objekte, Listen, ...
	\stdImg{v3.1}{Linq to Object}
	\stdImg{v3.2}{Linq to SQL}
	\stdImg{v3.3}{Linq to XML}
	
	\se{Erweiterungsmethoden}
		\uli{
			\li Bestehende Klassen um Methoden erweitern mit einer Statischen Klasse mit statischen Methoden durch die Angabe von ``this OriginalClass''.
			\li Reine Compilerfunktion. Der Compiler löst die Methode auf und schreibt ``ExtendOriginalClass.function()''
		}
		\stdImg{v3.5}{}
		\stdImg{v3.6}{Example}
		
		\sse{Predeclared Extension Methods}
			\stdImg{v3.7}{}
			\stdImg{v3.8}{Overrite Linq Extension Method}
			
		\sse{Object Initializers}
			\stdImg{v3.9}{}
			
		\sse{Anonyme Typen}
			Typensichere anonyme Typen, die zur Laufzeit generiert werden.
			\stdImg{v3.10}{Anonyme Typen aus Eigenschaften von Anonymen Typen bauen}
			\stdImg{v3.11}{Anonyme Typen aus Anonymen Typen bauen}
			\stdImg{v3.12}{Anonymous Type Details}
			\stdImg{v3.13}{Type Inference}
			
		\sse{Query Expression}
			\stdImg{v3.22}{}
			\stdImg{v3.14}{Umwandlung in Erweiterungssyntax}
			\uli{
				\li Compiler wandelt Query Expression um in Erweiterungssyntax
				\li 
			}
			\stdImg{v3.15}{Query Syntax}
			
			\sss{Grouping}
				\stdImg{v3.16}{Group into}

			\sss{Joining Lists}
				\stdImg{v3.17}{Join Lists}
				
			\sse{Select Many}
				Mehrstufingen Aufsplittprozess
				\stdImg{v3.18}{String split}
				
			\sss{Group Joins}
				Liste mit Sublisten ausgeben (Strukturierte Daten).
				\stdImg{v3.19}{Strukturierte Collection}
				\stdImg{v3.20}{Left Outer Join (wenn keine Daten zum Namen vorhanden wird null eingefügt)}
				
		\sse{System.Linq Extension Methods}
			\stdImg{v3.21}{}

		\sse{Partial Methods (Hooks)}
			Könnte auch mit Delegates und Interfaces umgesetzt werden. Vereinfacht nur die Schreibweise.
			\stdImg{v3.23}{}
			\stdImg{v3.24}{}
			\stdImg{v3.25}{Example}
			
			
\ch{Entity Framework}
	using (...) verwendet eine Resource die beim Beenden automatisch geschlosse wird.
	\stdImg{v4.1}{EF}
	\stdImg{v4.2}{EF Architektur}
	\stdImg{v4.3}{Providers}
	Entities sind Objekte mit einem Primärschlüssel weil sie einem Datensatz in der Datenbank entsprechen.
	\stdImg{v4.4}{OR Mapping}	
	\stdImg{v4.5}{}
	
	\se{Lazy Loading}
		\stdImg{v4.6}{}
		\stdImg{v4.7}{}
	
	\se{Eager Loading}
		\stdImg{v4.8}{}	
			
		
	\se{CUD Operationen}
		\stdImg{v4.9}{Create}
		\stdImg{v4.10}{Update}
		\stdImg{v4.11}{Delete}
		
		Context startet für jedes Objekt einen Change Tracker um mit saveChanges die Änderungen zurückschreiben zu können. ChangeTracker kennt immer original und current Wert. Damit können Änderungen rückgängig gemacht werden.
		\stdImg{v4.12}{Change Tracker Entity States}
	
	\se{Patterns}
		\sse{DB COntext}
			\uli{
				\li a combination of the Identity Map Pattern, Unit-Of-Work and Repository Pattern
				\li A DBSet<TEntity> represents the collection of all entities in the context
			}
			\stdImg{v4.13}{Identity Map}
	
			\stdImg{v4.14}{Unit Of Work Pattern}
	
			%\stdImg{}{Repository Pattern}
	
			\sss{Optimistic offline Lock}
				OR Mapper kann Lesen und Schreiben nicht in eine Transakton fassen. Darum braucht es eine Collision überwachung: Optimistic offline Pattern.
				\stdImg{v4.15}{Optimistic offline lock Pattern}
	
				\stdImg{v4.16}{verfahren für OOL}
				
				\important{Sobald verschachtelte Kontexte vorhanden sind, können Daten mit verschiedenen Versionen auftreten \ra\ EF kann kein Update machen. \ra\ Benutzer muss handeln.}
	
	\se{DB Mapping}
		\sse{in model}
			\stdImg{v4.17}{Annotations}
			\stdImg{v4.18}{Mapping über Annotations}
			Problem: Code mit DB Details verschmutzt.
		
		\sse{extern class}
			\stdImg{v4.20}{Mapping functions}
			\stdImg{v4.19}{DB Configuration ausserhalb model in externer Klasse}
			\stdImg{v4.21}{Relation Mapping}
			
			
\ch{Windows Communication Foundation WCF}
	\se{Basics}
	\expl{Unterschied Service Orientiert / Classic}{SO: Übertragen von ganzen Objekten und Objektlisten, eine Methoden. \\Classic: Anfrufen von Objekten, aufrufen von Methoden auf diesen, Aufrufen von save() zum Speichern.}

	\stdImg{v5.1}{Local Service}
	\stdImg{v5.2}{Remote Service}
	\stdImg{v5.3}{Kommunikation findet immer zwischen Endpunkten und nicht den Client statt}
	\stdImg{v5.4}{Address, Binding, Contract}
	\stdImg{v5.5}{Metadata Exchange (WSDL)}
	WSDL kann ein-/Ausgeschaltet werden und wird automatisch vom WCF generiert werden. Wird über einen sepparaten Endpoint ausgeliefert.
	
	\stdImg{v5.7}{Wer tut was?}

	\se{WCF use}
		\stdImg{v5.6}{}
		\stdImg{v5.18}{Address}
		\stdImg{v5.8}{Contracts}
		\stdImg{v5.9}{Service Config}
		\stdImg{v5.10}{Service COnfig im Code}
		Method Overloading beim Service geht nicht \ra\ Soap unterstützt kein Overloading!
		
	\se{Client}
		\uli{
			\li Nachteile generierter Client: 
				\uli{
					\li WSDL unterstützt unter Umständen Sprachfeatures nicht (Bsp. Properties)	
					\li SOAP kennt keine .Net Collections \ra\ Standard muss manuel definiert werden (z.B. SortedList) \ra\ keine Feingranulare zuteilung (Typeninfo geht verloren)
				}
			\li Shared Assembly: Schnittstellendefinition wird nicht über WSDL abgerufen sondern über ein Shared Assembly
			\li Nachtiele SA: 
				\uli{
					\li Assembly muss sowohl bei C wie S in der exakt gleichen Version vorhanden sein!
				}
			\li Vorteile SA:
				\uli{
					\li Servcice Informationen müssen bei den Clients nicht manuell nachgeführt werden (Config)
				}
		}

	\se{Communication Patterns}
		\stdImg{v5.11}{}
		
		\sse{Syncrhon}
			Nichts spezielles
			
		\sse{Asynchron}
			IsOneWay=true
			\stdImg{v5.12}{OneWay}
			\stdImg{v5.13}{Callback}
			Fehlt der Operation Contract, so können keine Messages Serialisiert werden!
			\stdImg{v5.14}{Service Setup (Vorsicht Fehler: Interface falsch)}
			\stdImg{v5.14}{Client INterface implementation (Vorsicht Fehler: ICalcResult statt ICalculatorResult)}
		
		\sse{Exception Übertragung}
			\uli {
				\li Service Host fängt über try-catch Exception ab und überträgt sie an den Client.
				\li FaultException ist die einzige Exception, die vom Server auf den Client geworfen kann.
				\li FaultException ist serialisierbar.
				\li FaultException kann weiteres Objekt mit Infos mitgegeben werden. Diesen erbt NIE von Exception, muss aber Serialisierbar sein.
					\stdImg{v5.16}{FaultException}
				\li Service muss FaultContract Annotation besitzen
				\li Client: Aufgrund des FaultContract ist die Exception bekannt \ra\ fangen. Als weiteres generische Exceptions fangen.
					\stdImg{v5.17}{Catch Client}
				\li Network not available wirft auch Exceptions!
			}
			
		\sse{Interoperability}
			\stdImg{v5.19}{Binding Possibilities}
			
			
		\sse{DataContract}
			\sss{Polymorphismus}
				\stdImg{v5.20}{}
			
			\sss{Unkow Types}
				Falls Entwickler .Net 1 Arraylist (untypisiert) verwendet:
				\stdImg{v5.21}{}
			
			\sss{Mehrfache Referenzen (Aliase)}
				\stdImg{v5.22}{}

			\sss{Umgang mit Änderungen der ServiceReferenz}
				\uli{
					\li Unbekannte Properties werden ignored.
					\li Entfernen von Properties: WCF nimmt default(T) wert. \ra\ kann mega Verwirrend sein!
				}
				
				
	\se{Service Behavior}
		Configuration wird auf der Implementation (Client) und nicht auf dem Service Interface gesetzt.
		
		
		
\ch{WPF}
	\stdImg{v6.1}{WPF Architecture}
	
	\se{Visual Tree \& Logical Tree}
		\stdImg{v6.2}{Visual Tree und Logical Tree}
		Dependency Property erben Darstellung von Parent.
		
		\stdImg{v6.3}{Auflödung von Elementproperties}
		\stdImg{v6.4}{}
		
	\se{Routed Events}
		Elemente ohne Eventhandler bubbeln die Events hoch in der Hierarchie. \\
		\examp{Beispiel Click auf einen Buttons ohne Eventhandler}{
			\uli{
				\li Sender: Stackpanel
				\li Source: Button
				\li Originalsource: Polyline im Button
			}
		}
	
		\expl{RoutingStrategy}{
			\uli{
				\li Tunneling raises the routed event at the root then to each
	element toward the source element
				\li Bubbling raises the routed event at the source element then to
	each element toward the root
				\li Direct raises the routed event at the source element only
			}
		}
	
		\stdImg{v6.5}{Routing Strategie}
		
	\se{Data Binding}
		Binding Fehler werden erst zur Laufzeit sichtbar, werfen jedoch keinen Fehler!
		\stdImg{v6.6}{Data Binding}
		\uli{
			\li Binding wird über DataContext gemacht.	
			\li INotifyPropertyChanged führt dazu, das das UI das Objekt im Datakontext und das UI aktualisiert.
			\li Klassen müssen INotifyPropertyChanged Events werfen, damit aktualisiert werden kann.
		}
		\stdImg{v6.7}{Binding}
		\stdImg{v6.8}{Data Converters}	
		\stdImg{v6.9}{Choose Data Template}
		
		\sse{Collection binding}
			\stdImg{v6.10}{Über Binding Data Template}
			\stdImg{v6.11}{Master Detail}
			
		\sse{Zusammenfassung}
			\uli{
				\li Data Binding Infrastructure
				\uli{
					\li Source: DP, Property with INotifyPropertyChanged
					\li Target: DP
					\li OneWay/Two Way
				}
				\li Data Context
				\li Data Template
				\li Value Converters
				\li Binding to Collections
			}
			
			
		\sse{Patterns}
			\stdImg{v6.12}{UI Command Pattern}
			\stdImg{v6.13}{MVP Pattern}
			
			\stdImg{v6.14}{MVP Pattern}
			\stdImg{v6.15}{MVVM Pattern}
		
			View Model enthält stati und Daten für die View (gehören nicht ins Datenmodel)
	
			\stdImg{v6.16}{ViewModel}
	
		\sse{Message Bus}
			\stdImg{v6.17}{Message Bus}
			
			
\ch{Threads, Tasks und asynchrone Programmierung}			
	\se{Parallel Loops}
		\stdImg{v7.1}{Parallel execution}
		
	\se{LINQ}
		\stdImg{v7.2}{AsParallel}
		
	\se{Tasks}
		\uli{
			\li Alle statischen .Net Methoden sind Thread Save
			\li Collections sind nicht Thread save Collections \ra\ ThreadsaveCollections	
			\li Work Stealing: Hat ein Worker nichts mehr zu tun und in der globalen Queue ist auch nichts, so klaut er Tasks von andern Threads zu hinterst aus deren Queue
				\stdImg{v7.3}{}
			\li Es gibt Background Threads und Foreground Threads. \ra\ Aufpassen wenn Thread Pool runtergefahren wird.
			\li 
				\stdImg{v7.4}{} 
				\uli{
					\li Task.Run(): Fire and forget
					\li Task.Wait(): Warten auf Beendigung
					\li var res = Task.Result(): Warten bis Beendet und Resultat da
						\stdImg{v7.5}{}
					\li Exception wird im Task drin gespeichert und bei Wait oder Result zurückgegeben, damit sie an einer Stelle abgefangen werden kann. \ra\ aggregateException (enthält je nach dem Mehrere)
						\stdImg{v7.6}{}
				}
		}
		
	\se{Async}
		\uli{
			\li Future: Regelmässig nachfragen ob Result da
			\li Callback: Funktionsaufruf bei Beendigung
		}
		
		\sse{Continuation}
			\stdImg{v7.7}{Continuation statt Callbacks}
			\stdImg{v7.8}{Continue with ruft andern Code auf (indirekter Callback)}
			
			
		\sse{async vs sync}
			\stdImg{v7.9}{}
			
		\sse{Async / Await}
			\stdImg{v7.10}{}
			
			async methode: Compile generiert im Hintergrund einen Awaiter
			
			
	\se{UI Tasks}
		\stdImg{v7.11}{}
		\stdImg{v7.12}{}
		\stdImg{v7.13}{}
		\stdImg{v7.14}{}
		
	\se{Async Cancelation}
		\stdImg{v7.15}{}
			
			
\ch{Reflection}
	\stdImg{v8.1}{Get Type}	
	\stdImg{v8.2}{Type}
	\stdImg{v8.3}{System.Type}
	\stdImg{v8.4}{Reflection Object Model}
	\stdImg{v8.5}{FieldInfo}
			
			
		

\end{document}
