%Pakete;
%A4, Report, 12pt
\documentclass[ngerman,a4paper,12pt]{scrreprt}
\usepackage[a4paper, right=20mm, left=20mm,top=30mm, bottom=30mm, marginparsep=5mm, marginparwidth=5mm, headheight=7mm, headsep=15mm,footskip=15mm]{geometry}

%Papierausrichtungen
\usepackage{pdflscape}
\usepackage{lscape}

%Deutsche Umlaute, Schriftart, Deutsche Bezeichnungen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

%quellcode
\usepackage{listings}

%tabellen
\usepackage{tabularx}

%listen und aufzählungen
\usepackage{paralist}

%farben
\usepackage[svgnames,table,hyperref]{xcolor}

%symbole
\usepackage{latexsym,textcomp}
\usepackage{amssymb}

%font
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

%durch- und unterstreichen
\usepackage{ulem}

%Abkürzungsverzeichnisse
\usepackage[printonlyused]{acronym}

%Bilder
\usepackage{graphicx} %Bilder
\usepackage{float}	  %"Floating" Objects, Bilder, Tabellen...
\usepackage[space]{grffile} %Leerzechen Problem bei includegraphics
\usepackage{wallpaper} %Seitenhintergrund setzen
\usepackage{transparent} %Transparenz

%Tikz, Mindmaps, Trees
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

%for
\usepackage{forloop}
\usepackage{ifthen}

%Dokumenteigenschaften
\title{Summary}
\author{Tobias Blaser}
\date{\today{}, Uster}


%Kopf- /Fusszeile
\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie

%Kopf-/ Fusszeile auf chapter page
\fancypagestyle{plain} {
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
}

\usepackage{changepage}

% Abkürzungen für Kapitel, Titel und Listen
\input{toolsAndCommands/shortcutsListAndChapter}
\input{toolsAndCommands/TextStructuringBoxes}

%links, verlinktes Inhaltsverzeichnis, PDF Inhaltsverzeichnis
\usepackage[bookmarks=true,
bookmarksopen=true,
bookmarksnumbered=true,
breaklinks=true,
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
menucolor=black,
pagecolor=black,
urlcolor=black
]{hyperref} % Paket muss unbedingt als letzes eingebunden werden!

\usepackage{graphicx}
\begin{document}

% Inhaltsverzeichnis
\tableofcontents
\clearpage


\ch{.Net}
	\se{CLR}
		\stdImg{v1.1}{Common Language Runtime}
		\expl{Managed Code}{Managed Code wird unter Aufsiicht des CRL ausgeführt (Security Manager, GC, ...)}
	
	\se{Common Type System CTS}
		\stdImg{v1.2}{CTS}
		\expl{Struct}{Wertobjekt, kein Ref. Type, unterschiedlich zu C!}
		
		\sse{Ref Types}
			\stdImg{v1.3}{Ref Type}
			XY.PointR entält Reflection Info.
			
		\sse{Value Types}
			\stdImg{v1.4}{Value Type (nur auf dem Stack}
			Konstruktor ist kein Konstruktor sondern nur ein Initialisierer der Werte auf dem Stack!
			
		\sse{Unterschiede}
			Aufpassen. Syntax genau gleich!
			\stdImg{v1.5}{Syntax / Hardware}
			\stdImg{v1.7}{Unterschiede Struct und Member}
			
		\sse{Boxing}
			\stdImg{v1.6}{}
			Boxing ist eine teuere Operation und erzeugt eine menge Garbage!
			
		\sse{MS Intermediate Language}
			\stdImg{v1.8}{IL}
			\stdImg{v1.9}{}
			\uli{
				\li Fehlt während der Laufzeit eine Klassenmethode als Native Code, wird der JIT Compiler aufgerufen und der IL Code mit dem Native Code ersetzt.	
				\li Typesafty kann zur Laufzeit überprüft werden in der IL
				\li IL wird nicht ausgeführt sondern zur Laufzeit compiliert!
			}
			
	\se{Assemblies}
		\expl{Assembly}{Deployment Einheit (exe, dll) im Portable Executable Format}
		\stdImg{v1.11}{}
		\expl{Module .Net}{IL Code+Metadata, Tools (z.B. ILDASM)
			\uli{
				\li C++: dll+Headerfile
				\li Java: Jar (Enthält Headerfileinfo werden über Reflection aus dem Jar extrahiert)
				\li .Net: dll/exe (wie Java)	
			}
		}
		\expl{Unterschied Komponente / Klasse in UML}{Komponente: Blackbox mit Interfaces}
		\stdImg{v1.10}{.Net dll}
		
		\sse{Type Resolution}
			Nicht über Filepath wie in Java sondern in den Metadata festgeschrieben.
			\stdImg{v1.12}{Assemblies Abhängigkeiten}
			
\ch{C\#}
	\se{Garbage Collection}
		\uli{
			\li Heap Algorithmus, läuft über erreichbarkeit, arbeitet mit Generationen.
			\li Aufräumen ist langsam, allozieren schnell.
		}
		
	\se{Namespaces}
		\stdImg{v1.13}{.Net Namespaces}
		\stdImg{v1.14}{Namespace und asso. DLL}
		
	\se{Classes}
		\stdImg{v1.15}{Alles wird UpperCamelcase benannt, nur Felder sind lowerCamelCase}
		
	\se{Einfache Typen}
		\stdImg{v1.16}{einfache Typen}
		
	\se{Referenztypen}
		\sse{Arrays}
			\stdImg{v1.17}{Unterschied jagged und block Array}
			
		\sse{Enum}
			\stdImg{v1.18}{}
			\stdImg{v1.19}{}
			
		\sse{String}
			\uli{
				\li Referenztyp
				\li Nicht modifizierbar (StringBuilder bentzen)
				\li Operatoren: +, [], Length
				\li Wertvergleich mit == und !=
			}
			
		\sse{Klassen}
			\stdImg{v1.20}{}
			\uli{
				\li Virtual kennzeichnet Methoden mit dnamic binding
				\li overwrite kennzeichnet Methodenüberschreibungen
				\li base. ruft Basiskonstruktor auf
			}
			\examp{Referenziertes Objekt wird = null zugewiesen}{Das Objekt wird vom GC abgeräumt, auch wenn noch referenzen darauf zeigen.}
			\stdImg{v1.21}{Unterschied Klasse und Structs}
			
		\sse{Boxing}
			Aufpassen mit Boxing! Auto-Boxing nur für lesende Zugriffe verwenden, nie für Zuweisungen.
		\sse{Punkt Operator}
			Punkt Operator wird sowohl für Dereferenzierung wir für Feldzugriff verwendet. (In C++ wird der Pfeil als Dereferenzierungsoperator verwendet und der Punkt nur für Felderzugriff (Klasse, Struct).
			
	\se{Klassen}
		\sse{Methoden}
			\uli{
				\li Mit ref deklarierte Variable muss auch wieder mit ref angesprochen werden.
			}
			\stdImg{v1.22}{Arten von Parametern}
		
		
		\sse{Konstruktoren}
			\stdImg{v1.23}{}
		
			\sse{Statische Konstruktoren}
				\stdImg{v1.24}{Statische Konstruktoren}
			
		\sse{Destruktor}
			Ist genau genommen ein finalizer und kein Destruktor. Macht den GC langsam.
		
		\sse{Properties}
			\definition{Properties}{Berechnete Felder}
			\stdImg{v1.25}{Properties}
		
			\sse{Automatische Konstruktoren}
				\begin{verbatim}
					public string Name { get; set; }
				\end{verbatim}
			
		\sse{Indexer}
			\definition{Indexer}{Index Operator}
			\stdImg{v1.26}{}
		
		\sse{Vererbung}
			Syntax wie bei C++:
			\begin{verbatim}
				class B:A {
					...
				}
			\end{verbatim}

			\expl{Statische und dynamische Typen}{
				\\
					A a = new A(); // statischer Typ von a ist immer A, dynamischer Typ ist hier auch A\\
					a = new B(); // statischer Typ unverändert, dynamischer Typ ist B
				\\
			}
		
			\stdImg{v1.27}{Geprüfte Typenumwandlungen}
		
			\sss{Dynamic Binding}
				\expl{Statische und dynamische Methodenaufrufe}{Beim Virtual Binding geht die Methodenauflösung über das Objekt und über dessen Klasse, beim statischen Binding direkt über den Basistyp \ra\ ruft Methode des Basistyps auf.}
				\expl{virtual und dynamic binding}{Virtual braucht es nur dann, wenn ANSTELLE des Objektes A, ein Kindobjekt verwendet werden soll. Z.B. eine Schnittstelle, die A-Objekte oder A-Kinder erwartet. In der Realität ist der Fall sehr selten und darum bei C\# nicht standard.}
				\examp{Dynamic Binding}{User Interface mit Window Elementen wie Buttons, Scrollpane, ... die alle von ``Window'' abgeleitet sind. Der Window Manager besitzt eine Collection mit ``Window'' Elementen, durch die er iteriert und für jedes Objekt seine eigene paint methode ``public void paint()'' aufruft. Bei Static Binding würde die paint() Methode der Window Klasse aufgerufen und nicht diejenige des übergebenen Elementes.}
			
				\important{new virtual verdeckt weitere Overrides von Obgeleiteten Klassen. Der Compiler geht von oben nach unten in der Klassenhirarchie. new virtual unterbricht diese Hirarchie.}
				\stdImg{v1.29}{DB mit Verdecken}
			
			\sss{Ober- und Unterklassen Konstruktoren}
				Statische Elemente vor Dynamischen! Statische Felder vor Instanzfelder!
				\stdImg{v1.30}{}
				\stdImg{v1.31}{}
			
	\se{Interfaces}
		Methoden sind per default public, dürfen also nicht public definiert werden \ra\ Kompiler motzt sonst.
	
		\begin{verbatim}
			class MyClass : MyInterface {
		
			}
		\end{verbatim}
			
		\sse{Named Clashes}
			Mehrere Interfaces mit gleicher Methode \ra\ angeben welche man implemtentiert (optional).
			\stdImg{v1.32}{Named Clashes}
			
	\se{Optionale Parameter}
		\stdImg{v1.33}{Optionale Parameter}
		Ist der optionale Parameter nicht der hinterste, kann man durch naming diesen angeben:
		\begin{verbatim}
			function(int a, int b, aut = 5, int from, int aso, int to = 100) {
				...s
			}
		
			function(a, b, from: 100, to: 200);
		\end{verbatim}

	\se{Partial Methods}
		Hooks
		\stdImg{v1.34}{}
		Nur verwenden für Code Generatoren!

	\se{Delegates}
		\definition{Delegate}{Methodentyp. Methode als Variable übergeben wie im JS. Methode wird anschliessend aufgerufen.}
		\stdImg{v1.35}{Delegate}
		
	\se{Events}












\end{document}
